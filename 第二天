算法学习|第二天|代码随想录
第一题
977.有序数组的平方 
给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。
算法思路
vector<int> result
k = num.size - 1
for (int i=0, j=num.size-1; i<=j;  )
  if (nums[i] * nums[i] > nums[j]*nums[j])
    result[k--] = nums[i] * nums[i];
      i++;
  else {
    result[k--] = nums[j] * nums[j]
      j--;
  }
return results;

方法一、暴力排序
每个数平方之后，再进行排序
class Solution {
public:
  vector<int> sortedSquares(vector<int>& A) {
    for (int i=0; i<A.size(); i++) {
      A[i] *= A[i];
    }
    // 快速排序
    sort(A.begin(), A.end());
    return A;
  }
};

方法二、双指针法
有序数组的最大值在数组的两端。
考虑双指针法，i指向起始位置，j指向终止位置。
定义一个新数组result，和 nums 数组一样的大小，让k指向 result 数组终止位置。
class Solution {
public:
  vector<int> sortedSquares(vector<int>& nums) {
    int k = nums.size() - 1;
    vector<int>& result(nums.size(), 0);
    // 最后两个元素需要排序
    for (int i=0, j=nums.size()-1; i<=j;) {
      if (nums[i] * nums[i] < nums[j] * nums[j]) {
        result[k--] = nums[i] * nums[i];
        j--;
      } else {
        reuslt[k--] = nums[j] * nums[j];
        i++;
      }
    }
    return results;
  }
}


第二题
209.长度最小的子数组
给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。
方法一、暴力解法
方法二、滑动窗口
  





  










59.螺旋矩阵II
